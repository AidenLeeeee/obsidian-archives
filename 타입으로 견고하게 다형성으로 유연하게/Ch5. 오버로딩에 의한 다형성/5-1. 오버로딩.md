여러 타입을 받아 각각 다른 동작을 수행하는 함수를 정의하기 위해서는 아래와 같이 타입가드를 구현해주어야 한다. 이는 생각보다 귀찮고 불편한 일이다. 함수가 받을 수 있는 타입이 늘어나게 되면, 그에 맞는 타입 가드를 모두 추가해주어야 하기 때문이다.

```java
Void write(Cell cell, String | Int data) {
	if (data is String) {
		cell.setDataFormat(DATA_FORMAT_NORMAL);
		cell.setData(data);
	} else {
		cell.setDataFormat(DATA_FORMAT_NUMBER);
		cell.setData(intToString(data));
	}
}
```

**함수 오버로딩**은 한 함수가 여러 타입의 인자를 받아야 할 때 위와 같은 유니온 타입보다 훨씬 간단하고 직관적인 해결책을 제공하는 기능이다.

함수 오버로딩은 같은 이름의 함수를 여러 개 정의하는 것이다.
단, 이 때 이름이 같은 함수들의 매개변수 타입은 서로 달라야 한다.

원래는 한 이름의 함수를 하나만 정의해야 하지만, 개발자의 편의를 위해 같은 이름의 함수를 많이 정의할 수 있도록 하는 기능인 셈이다.

함수 오버로딩을 사용하면, 위 함수를 아래와 같이 구현할 수 있다.

```java
Void write(Cell cell, String str) {
	cell.setDataFormat(DATA_FORMAT_NORMAL);
	cell.setData(str);
}

Void write(Cell cell, Int num) {
	cell.setDataFormat(DATA_FORMAT_NUMBER);
	cell.setData(intToString(num));
}
```

위 예제에서 write 이름을 가진 함수는 두 개가 되었고, 각 함수의 매개변수 타입이 서로 다르므로, 올바른 오버로딩이다.

오버로딩된 함수를 호출할 때는 오버로딩이 아닌 경우와 동일하게 함수 이름을 적으면 된다.

```java
Cell c1 = ...;
Cell c2 = ...;
write(c1, "Hello");
write(c2, 42);
```

어떤 함수를 호출할지는 언어 수준에서 자동으로 결정된다.
이렇게 함수가 오버로딩되어 있을 때 호출할 함수를 자동으로 고르는 것을 **함수 선택**이라고 한다.
함수 선택의 가장 기본적인 규칙은 '인자의 타입에 맞는 함수를 고른다'는 것이다.

결국, 개발자 입장에서는 함수를 오버로딩하지 않은 경우와 완전히 같은 방법으로 함수를 호출할 수 있다.
호출하려는 함수가 오버로딩되었는지 아닌지 고려할 필요가 없는 것이다.

함수 오버로딩은 다형성을 만들어 내는 세 번째 방법으로, 이렇게 같은 이름을 여러 번 정의함으로써 만들어지는 다형성을 오버로딩에 의한 다형성(ad hoc polymorphism)이라 부른다.

여기서 오버로딩이란 함수 오버로딩, 메서드 오버로딩, 연산자 오버로딩을 모두 통틀어 일컫는 용어다.
함수 오버로딩이 같은 이름의 함수를 여럿 정의하는 것이듯, 메서드 오버로딩과 연산자 오버로딩은 각각 메서드와 연산자를 여럿 정의하는 것이다.

- 메서드 오버로딩
오버로딩의 대상이 함수에서 메서드로 바뀌었을 뿐, 개념은 동일하다.
즉, 한 클래스에서 이름이 같고 매개변수 타입이 다른 함수를 여럿 정의하는 것이다.
이 경우, 메서드 선택(method dispatch)을 통해 호출될 메서드가 정해진다.

### 세 다형성의 만남

오버로딩에 의한 다형성을 서브타입에 의한 다형성이나 매개변수에 의한 다형성과 함께 사용하면 흥미로운 개념이 추가로 등장한다.

#### 오버로딩 + 서브타입 다형성

앞서 본 write 함수에서는 어느 함수가 호출될지 항상 명확했다.
자동으로 인자의 타입과 일치하는 매개변수 타입을 가지는 함수가 호출되기 때문이다.
하지만 이러한 경우에서 서브타입 다형성이 추가되면 조금 더 복잡해진다.

```java
class Vector {
	List<Int> entries;
}
```

위 Vector 클래스는 벡터의 원소들을 나타내는 entries 필드를 가진다.
이 때 주어진 벡터의 길이를 구하는 length 함수를 정의하면 아래와 같을 것이다.

```java
Int length(Vector v) {
	v.entries[i]...
}
```

벡터에 원소가 많다면 길이를 계산하는 연산 시간이 늘어나기 때문에 0을 많이 가진 벡터만 따로 특별하게 처리하면 성능에 도움이 된다.
0이 아닌 원소의 위치를 미리 기억해 두면, 이러한 벡터의 길이를 구할 때는 0이 아닌 원소들만 고려함으로써 계산에 걸리는 시간을 크게 줄일 수 있기 때문이다.

```java
class SparseVector extends Vector {
	List<Int> nonzeros;
}
```

위 SparseVector 클래스는 상속받은 entries 필드에 nonzeros 필드를 추가로 가진다.
nonzeros 는 0이 아닌 원소들의 인덱스를 나타낸다.

위 SparseVector 의 길이를 구하는 length 함수는 아래와 같을 것이다.

```java
Int length(SparseVector v) {
	v.entries[v.nonzeros[i]]...
}
```

지금까지 오버로딩된 함수는 두 개이며, SparseVector 는 Vector 의 서브타입이다.

```java
Int length(Vector v) { ... }
Int length(SparseVector v) { ... }
```

이제 이렇게 구현된 length 함수를 사용해볼텐데, 사실 일반적인 Vector 의 길이를 계산할 때는 어려울 게 없다.

```java
Vector v = Vector(...);
length(v);
```

인자의 타입이 Vector 이므로, 첫 번째 length 함수가 자동으로 선택될 것이다.

하지만 SparseVector 의 길이를 계산하려고 하면 새로운 고민거리가 생긴다.

```java
SparseVector v = SparseVector(...);
length(v);
```

인자의 타입이 SparseVector 이기 떄문에 두 length 함수를 모두 호출 가능하기 떄문이다.
즉, SparseVector 가 Vector 의 서브타입이기 때문에 인자의 타입을 만족하는 함수가 두 개 이상이 된 것이다.

이 경우, 함수 선택의 두 번째 규칙이 사용된다.
함수 선택의 두 번째 규칙은 '인자의 타입에 가장 특화된(most specific) 함수를 고른다'는 것이다.
따라서 인자의 타입이 SparseVector 인 경우, 매개변수 타입이 SparseVector 인 두 번째 함수가 자동으로 선택되어 호출된다.
두 번째 length 함수는 SparseVector 의 길이만 구할 수 있는 함수이기 때문에 SparseVector 의 길이를 구하는 데 첫 번째 함수보다 더욱 특화된 경우라고 볼 수 있다.

하지만 이렇게 '가장 특화된'이나 '더욱 특화된'이라는 표현은 타입 검사기의 입장에서 애매모호한 표현이다.
따라서 한 함수가 다른 하나보다 더 특화되었다는 말은 '한 함수의 매개변수 타입이 다른 함수의 매개변수 타입의 서브타입'이라는 말로 일반화할 수 있을 것이다.
이 때 매개변수가 여럿이라면, 순서대로 각 매개변수 타입이 서브타입 관계에 있는지 확인한다.

이처럼, 가장 특화된 함수라는 개념이 서브타입으로 표현될 수 있기 때문에 함수 선택 시 타입 검사기과 관여한다.
서브타입 관계를 바탕으로 각 함수의 매개변수 타입을 비교하여 어느 함수가 더 특화되었는지 알아내는 것이다.

추가적으로, 아래와 같은 경우가 있을 수 있다.

```java
Vector v = SparseVector(...);
```

위 경우에 타입 검사기가 알고 있는 v 의 타입은 Vector 이지만(정적타입), 실제로 프로그램을 실행할 때 가지고 있는 가장 정확한 타입(동적타입)은 SparseVector 일 것이다.
이 경우에는 함수 선택 시 정적타입과 동적타입 중 어떤 타입을 고려하게 될까?

대부분의 언어에서는 함수 선택 시에 정적타입만을 고려한다.
이렇게 정적 타입을 바탕으로 함수를 선택하는 것을 **정적 선택(static dispatch)** 라고 부른다.
타입 검사를 통해 인자의 정적타입을 알아낸 뒤, 실행하기 전에 호출할 함수를 미리 선택하는 것이다.

실제로 정적타입과 정적 선택에 대해 이해하지 못한 상태로 오버로딩을 사용한 프로그램을 구현할 경우, 비효율적인 코드를 작성하게 될 수도 있기 때문에 조심하는 것이 좋다.

이러한 문제를 사전에 방지하기 위해서는 서브타입을 위한 함수 오버로딩을 애초부터 사용하지 않는 것이 좋다.
오버로딩은 완전히 다른 타입들의 값을 인자로 받는 함수들을 정의하는 용도로만 사용하자.

만약 서브타입을 구분하여 서로 다른 동작을 수행하는 함수를 꼭 정의하고 싶다면, **메서드 오버라이딩**(method overriding)을 사용하는게 좋을 것이다.

