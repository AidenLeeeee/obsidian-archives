### 카인드의 개념과 활용

```java
Int length<T>(ArrayList<T> list) { ... }
Int length<T>(LinkedList<T> list) { ... }
Void add<T>(ArrayList<T> list, T elem) { ... }
Void add<T>(LinkedList<T> list, T elem) { ... }
```

위 코드는 리스트의 길이를 구하는 함수와 원소를 추가하는 함수를 오버로딩을 통해 구현한 예시이다.
인자는 각각 배열 리스트와 연결 리스트를 사용할 수 있도록 구현되어 있다.

이제 length 와 add 를 사용해 아래와 같은 배열 리스트를 다루는 함수를 정의할 수 있다.

```java
Void addUntil<T>(ArrayList<T> list, T v, Int len) {
	while (length<T>(list) < len) {
		add<T>(list, v);
	}
}
```

addUntil 은 리스트, 리스트에 추가할 값, 리스트의 목표 길이를 인자로 받아 계속해서 값을 추가한다.
물론 이 함수는 배열 리스트가 아닌 다른 리스트도 모두 호환되어 동작 가능한 함수이다.

```java
Void addUntil<T>(LinkedList<T> list, T v, Int len) {
	while (length<T>(list) < len) {
		add<T>(list, v);
	}
}
```

위처럼 연결 리스트를 위한 함수로도 정의할 수 있는 것이다.

다만 이렇게 정의해도 잘 동작하지만, 두 함수의 몸통이 완전히 똑같다.
또한 배열 리스트와 연결 리스트 이외의 다른 타입의 리스트를 위한 함수를 정의해야 하는 경우에는 몸통이 동일한 addUntil 함수를 추가로 정의해야 할 것이다.

따라서 이 때 우리는 매개변수에 의한 다형성을 활용할 수 있다.

```java
Void addUntil<L, T>(L<T> list, T v, Int len) {
	while (length<T>(list) < len) {
		add<T>(list, v);
	}
}
```

이제 addUntil 은 타입 인자 두 개를 받는 제네릭 함수이다.
첫 번째 타입 인자인 L 은 리스트의 타입을 나타내고, 두 번째 타입 인자인 T 는 리스트를 구성하는 원소의 타입을 나타낸다.

만약 정수를 담고 있는 배열 리스트에 원소를 추가하고 싶다거나, 문자열을 담고 있는 연결 리스트에 원소를 추가하고 싶다면,

```java
addUntil<ArrayList, Int>(...);
addUntil<LinkedList, String>(...);
```

위와 같이 사용할 수 있다.

하지만 위 코드에는 치명적인 오류가 있다.
바로 아래와 같이 함수가 정상적으로 동작하지 않는 경우의 타입을 인자로 전달할 수 있다는 것이다.

```java
addUntil<Int, String>(...);
addUntil<LinkedList, ArrayList>(...);
```

Int 는 제네릭 타입이 아니다. 따라서 `Int<String>` 이라는 타입은 존재하지 않는다.
또한 ArrayList 는 제네릭 타입이다. 즉 사용할 때 타입 인자를 받아야만 한다. `LinkedList<ArrayList>` 와 같은 타입은 존재하지 않는 것이다.

결국 우리는 타입의 여러 종류를 이해하고 이를 각각 구분하여야만 한다.

#### 1. 타입의 값들이 존재하는 타입
Int 나 String 과 같이 타입 인자를 받을 필요없이 매개변수 타입이나 결과 타입으로 사용할 수 있는 타입들이 여기에 속한다.