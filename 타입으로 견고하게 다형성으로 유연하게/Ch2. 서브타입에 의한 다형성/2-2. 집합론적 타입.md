## 최대 타입(top type)

최대 타입은 **가장 큰 타입**이다.
즉, '이 부품의 결과는 아무 값이나 될 수 있다'를 표현하는 타입이다.

결국 **모든 타입은 최대 타입의 서브타입**이 되며, 이를 Any 라고 부르거나, unknown 이라고 부른다.

## 최소 타입(bottom type)

최소 타입은 예외를 다루는 데 유용한 타입이다.

예외는 언제나 값을 반환하지 못하고 프로그램의 실행을 종료시킨다.
다시 말해 예외가 사용될 곳이 어떤 타입을 사용하고 있던 상관없는 것이다.
어차피 예외는 값을 반환할 일이 없기 때문에 어떤 곳에서도 사용이 가능하다.

물론 정적 타입 언어에서는 어떤 값이든 타입을 명시해야 하기 때문에 이러한 예외도 타입을 지정해주어야 한다.
즉, '계산을 끝마치지 못한다'를 표현할 수 있는 타입을 찾아야 하는 것이다.
그 타입이 바로 최소 타입이다.

최소 타입은 어떤 값도 속하지 않는 타입이다. 그렇기에 '가장 작은' 타입이라고 할 수 있다.
어떤 값도 속하지 않는다는 점에서 Void 와 동일하다고 생각될 수 있지만, Void 와 최소 타입은 전혀 다르다.
Void 는 함수가 계산을 끝낼 때 어떤 값도 반환하지 않는다는 사실을 나타내지만, 최소 타입은 함수가 계산을 끝마치지 못한다는 사실을 나타낸다.

**최소 타입의 가장 중요한 특징은 모든 타입의 서브타입이라는 것**이다.
바로 이러한 점 덕분에 최소 타입을 가진 값은 어디에서나 타입 검사를 통과할 수 있다.

위와 같은 점은 최대 타입과 최소 타입을 혼동하게 만드는 요인이 될 수 있는데, **최대 타입이 '아무 값이나 될 수 있다'** 를 의미한다면, **최소 타입은 '아무 곳에서나 사용될 수 있다'** 를 의미한다.

최대 타입의 부품은 만들기 쉽다. 아무 부품이나 최대 타입의 부품으로 간주할 수 있기 때문이다. 그런만큼 최대 타입의 부품은 아무 값이나 결과로 낼 수 있기에 결과로 나온 값이 어떤 능력을 가지는지 모른다. 따라서 최대 타입의 부품은 조심스럽게, `console.log()` 의 인자처럼 별다른 특별한 능력을 요구하지 않는 곳에서만 사용해야 한다.
만약 특별한 능력을 요구하는 곳에서 최대 타입의 값을 사용했다가, 해당 값이 능력을 가지고 있지 않다면 프로그램 오류로 이어질 것이기 때문이다.

반대로 최소 타입의 부품은 계산을 끝내지 못한다. 따라서 결과로 나온 값이 사용되는 순간이 영원히 오지 않는다. 따라서 최소 타입은 아무렇게나 어떤 곳에던 사용할 수 있다.
하지만 최소 타입의 부품은 만들기가 어렵다. 예외를 발생시키거나 무한히 재귀 호출을 하는 등의 특별한 방법으로만 최소 타입의 부품을 만들 수 있다.

이는 Nothing 이라 부르거나, never 로 불린다.

## 이거나 타입(union type)

유니온 타입은 두 개의 타입으로부터 만들어진다.
타입 A 와 B 로 만든 유니온 타입은 A | B 라 쓰며 직관적으로 'A 이거나 B' 를 나타낸다.
즉, 어떤 값이 A 에 속하면 A | B 에 속하고, B 에 속해도 A | B 에 속한다.

인자의 타입에 따라 다른 동작을 수행하는 함수를 정의할 때 활용하기 좋은데, 이는 유니온 타입을 활용하면 인자의 타입별로 다른 함수를 만들 필요없이 하나의 함수에서 여러 타입을 인자로 받을 수 있기 때문이다.

하지만 유니온 타입을 사용할 때는 한 가지 주의할 점이 있다. 이는 **위치에 민감한 타입 검사(flow-sensitive type checking)** 이라는 개념과 깊은 연관이 있다.

```java
Void write(Cell cell, String | Int data) {
	if (data is String) {
		cell.setDataFormat(DATA_FORMAT_NORMAL);
		cell.setData(data);
	} else {
		cell.setDataFormat(DATA_FORMAT_NUMBER);
		cell.setData(intToString(data));
	}
}
```

위 코드는 String 혹은 Int 타입인 데이터를 받아 cell.setData(data) 를 활용해 데이터를 저장한다.
사실 위 함수는 실제로 타입을 통과하는 함수이다. 하지만 어떻게 그럴 수 있을까?
실제로 cell.setData() 함수는 String 타입의 인자만 받을 수 있다.
인자가 String 혹은 Int 타입이라면 위 코드 내 cell.setData(data) 와 cell.setData(intToString(data)) 모두 타입 오류를 발생시켜야 당연한 것이다.

하지만 분명히 write 함수는 잘못 구현되지 않았다. 개발자 입장에서는 data is String 이라는 if 구문을 이용해 data 가 문자열인 경우와 정수인 경우를 나누어 처리하고 있기 때문에 문제가 없는 코드인 것이다. 이렇게 간단한 코드조차도 타입 검사를 통과할 수 없다면 유니온 타입을 사용하는 의미가 없다.

바로 위와 같은 문제 때문에 유니온 타입을 제공하는 언어는 위치에 민감한 타입 검사라는 정교한 방식의 타입 검사를 사용한다.
변수의 값을 읽는 부품의 타입을 검사할 때 해당 변수가 정의된 곳의 타입 표시만 보는 것이 아니라, 그 변수가 어디서 사용되는지도 고려하는 것이다.

위와 같은 경우에서는 cell.setData(data) 는 data is String 이 true 인 경우에만 실행되고, intToString(data) 는 data is String 이 false 인 경우에만 실행된다.
따라서 cell.setData(data) 를 검사할 때는 data 의 원래 타입이 String | Int 였다는 정보에 더해 현재 data is String 이 true 라는 정보까지 활용해 data 의 타입이 String 이라고 결론 짓게 된다.
바로 이와 같은 원리로 위 write 함수의 타입 검사가 성공하게 되는 것이다.

하지만 위치에 민감한 타입 검사에도 한계는 존재한다. 프로그램이 복잡해지면 위치로부터 정보를 얻을 수 없게 된다는 것이다.

```java
Void write(Cell cell, String | Int data) {
	if (isString(data)) {
		cell.setDataFormat(DATA_FORMAT_NORMAL);
		cell.setData(data);
	} else {
		cell.setDataFormat(DATA_FORMAT_NUMBER);
		cell.setData(intToString(data));
	}
}

Boolean isString(Any data) {
	return data is String;
}
```

위 코드는 write 함수를 조금 변경한 함수이다.
바뀐 부분은 data is String 이 isString(data) 라는 함수로 대체되었다는 점이다.
isString 이 결국 data is String 을 계산하기 때문에 프로그램이 실행 중에 하는 일은 이전과 똑같다. 하지만 타입 검사기의 입장은 다르다.

data is String 은 언어가 원래 제공하는 기능인 is 를 사용한 것이므로 타입 검사기가 data is String 을 특별하게 처리할 수 있다.
cell.setData(data) 에서는 data 가 문자열이고 intToString(data)에서는 data 가 문자열이 아니라는 정보를 얻을 수 있었던 것이다.

반면 isString(data) 는 일반적인 함수 호출로, 개발자가 정의한 임의의 함수이다.
타입 검사기가 isString(data)를 특별하게 처리할 이유가 없는 것이다.
그래서 cell.setData(data)에서는 data 가 문자열이고 intToString(data)에서는 data 가 문자열이 아니라는 정보를 얻을 수 없다. 결국 위치에 민감한 타입 검사를 사용하지 않는 것처럼 data 의 타입이 항상 String | Int 인 것으로 처리되어 타입 검사를 통과하지 못한다.

정리하면, **유니온 타입을 사용하기 위해서는 위치에 민감한 타입 검사가 잘 동작하도록 프로그램의 구조를 단순하게 만들어야 한다는 점**이다. data is String 과 같이 값의 타입을 실행 중에 확인하는 부품을 if 문의 조건으로 바로 사용해야 한다.

## 이면서 타입(intersection type)