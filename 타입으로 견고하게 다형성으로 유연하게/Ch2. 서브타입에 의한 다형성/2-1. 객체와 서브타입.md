## 서브타입에 의한 다형성

서브타입에 의한 다형성은 객체를 다룰 때 유용하다.
객체라는 개념이 있는 정적 타입 언어라면 서브타입에 의한 다형성도 제공하는데, 이는 객체를 사용할 때의 불편을 크게 줄여 주는 윤활유의 역할을 한다.

#### 예시

```java
class Person {
	String name;
	String email;
	Int id;
}

class Student extends Person {
	Int grade;
	Float gpa;
	Boolean paid;
}
```

Person 클래스와 Person 클래스를 상속하는 Student 클래스를 정의했다.

```java
Void sendEmail(Person person, String title, String content) {
	String email = person.email;
	...
}
```

Person 타입의 인스턴스를 첫 번째 인자로 받아 메일을 전송하는 함수를 정의했다.

```java
for (Int i = 0; i < students.length; i++) {
	Student st = students[i];
	if (!st.paid) {
		sendEmail(st, ..., ...);
	}
}
```

`sendEmail()` 함수의 첫 번째 인자로 Student 클래스의 인스턴스를 넘겨주고 있다.
만약 서브타입에 의한 다형성을 제공하지 않는 언어라면 위와 같은 코드는 타입 오류가 발생할 것이다.
`st` 변수에 담긴 학생의 타입은 Student 이지만, `sendEmail()` 함수는 Person 타입의 인자를 필요로 하기 때문이다.

위와 같은 일이 발생하지 않도록 하기 위해서는 `st` 의 타입을 Person 으로 추론할 수 있게 만드는 것이 필요한데, 이 것이 바로 **서브타입에 의한 다형성**이다.

서브타입에 의한 다형성은 `st` 가 Student 타입에 속하면서 동시에 Person 타입에도 속하게 만든다.
즉, 서브타입이라는 개념을 통해 특정한 값이 여러 타입에 동시에 속하도록 다형성을 부여하는 것이다.

#### 서브타입

서브타입은 "A는 B다" 라는 타입 사이의 관계다.
"A는 B다"라는 설명이 올바르다면 A는 B의 서브타입이다.
또한 서브타입에 반대되는 의미로서 슈퍼타입(supertype)이라는 용어를 사용하기도 하는데, 만약 A 가 B 의 서브타입이면 B 는 A 의 슈퍼타입이다.

위 예시에서는 Student 가 Person 의 서브타입이고 Person 은 Student 의 슈퍼타입이 된다.
이는 "사람은 학생이다"가 틀린 명제이기 때문이다. 세상에는 학생 이외의 사람도 있기 때문에 Person 은 Student 의 서브타입이 아니고 Student 는 Person 의 슈퍼타입이 아니다.

#### 서브타입에 의한 다형성

즉, A 가 B 의 서브타입일 때 A 타입의 부품을 B 타입의 부품으로도 간주할 수 있게 하는 기능이 서브타입에 의한 다형성이다.
B 타입의 부품이 요구되는 자리에 A 타입의 부품이 오더라도 타입 검사기가 문제를 삼지 않는 것이다.

그렇다면 서브타입에 의한 다형성이 말이 되는 이유는 무엇일까?
다시 말해, 서브타입에 의한 다형성을 제공하더라도 타입 검사기의 가장 중요한 성질인 타입 안정성에 문제가 생기지 않는 이유는 무엇일까?

만약 Person 타입의 부품이 필요한 곳이 있다고 했을 때, 그곳에서는 Person 타입의 값이 지닌 어떤 능력을 필요로 할 것이다.
이 때 Student 타입의 부품이 그 곳에 사용되어도 괜찮을 것이다.
Student 가 Person 의 서브타입이므로 Person 타입의 부품이 가진 능력을 Student 타입의 부품도 가지고 있을 것이기 떄문이다.

중요한 것은 서브타입에 의한 다형성은 '반대 방향'으로 적용할 수 없다는 사실이다.
즉 A 가 B 의 서브타입일 때 A 타입의 부품이 요구되는 곳에 B 타입의 부품이 오는 것은 타입 검사기가 허용하지 않는다.
Student 타입의 부품이 필요한 곳에 Person 타입의 부품을 함부로 사용해서는 안된다.
Student 타입의 부품이 가진 능력을 Person 타입의 부품은 가지고 있지 않을 수 있기 때문이다.

#### 서브타입 다형성의 활용

타입 검사기는 명확한 규칙에 따라 서브타입 관계를 판단한다.
그 규칙만 파악한다면 타입 검사기가 A 를 B 의 서브타입으로 판단할지 아닐지 알 수 있다.

타입 검사기가 객체 타입의 서브타입 관계를 판단할 때 사용하는 규칙에는 아래 두 가지가 있다.

1. 이름에 의한 서브타입(nominal subtyping)
   - 타입이 알려 주는 이름을 바탕으로 서브타입 관계를 판단

2. 구조에 의한 서브타입(structural subtyping)
   - 타입이 알려 주는 구조를 바탕으로 서브타입 관계를 판단

위 두 방법을 병용하는 언어도 있고 둘 중 하나만 사용하는 언어도 있다.

#### 이름에 의한 서브타입

이름에 의한 서브타입을 사용하는 경우, 타입 검사기는 타입이 보여주는 클래스의 이름과 클래스 사이의 상속 관계만 고려한다.
즉, 해당 클래스가 어떻게 생겼는지 혹은 그 클래스에 어떤 필드와 메서드가 있는지는 전혀 신경 쓰지 않는다.
따라서 클래스 A 가 클래스 B 를 상속한다면 A 가 B 의 서브타입이다.

1. 직접 상속(direct inheritance)
   앞선 예시의 Student 와 Person 처럼, 특정 클래스를 정의할 때 해당 클래스가 상속할 클래스 목록에 직접 포함되어 있는 상속은 직접 상속에 해당한다.

2. 간접 상속(indirect inheritance)
   어떤 클래스를 상속하는 클래스를 다시 상속하는(또는 같은 방식으로 더 많은 클래스를 거치는) 상황을 말한다.

#### 구조에 의한 서브타입

다른 라이브러리를 사용할 때처럼, 이미 정의된 클래스를 수정할 수 없는 경우에는 이름에 의한 서브타입만으로는 부족할 수 있다.
그럴 때는 구조에 의한 서브타입이 필요하다.

구조에 의한 서브타입을 사용하는 경우, 타입 검사기는 클래스 사이의 상속 관계 대신 클래스의 구조, 즉 각 클래스에 어떤 필드와 메서드가 있는지 고려한다.
클래스 A 가 클래스 B 에 정의된 필드와 메서드를 모두 정의한다면 A 는 B 의 서브타입이다.

1. 구조를 드러내는 타입(structural type)
   이름만 보여 주는 방식의 타입은 이름을 드러내는 타입(nominal type)이라고 한다.
   반면 구조를 드러내는 타입은 객체가 가지는 필드와 메서드를 그냥 나열한 것이다.
   예를 들면 `{ String email; }` 은 구조를 드러내는 타입이다.
   이 타입에는 String 타입의 필드 email 을 가지는 객체들이 속한다.
   객체에 email 이외의 필드나 메서드가 더 있어도 괜찮다.

이렇게 구조를 드러내는 타입을 사용하면, 클래스를 직접 정의하지 않고도 특정 필드와 메서드를 기준으로 인자로 받을 수 있는 타입을 정확하게 선별할 수 있다.

#### 추상 메서드

필드와 마찬가지로, 함수인 메서드 역시 타입 표시가 필요하다.
정적 타입 언어에서 메서드를 사용할 때는 추상 메서드(abstract method) 개념을 알면 편리하다.

추상 메서드는 실제로 메서드를 정의하지는 않고, '이 클래스를 상속하려면 특정 메서드를 반드시 정의해야 한다'는 사실을 표현하는 것이다.

```java
abstract class EmailDst {
	Void sendEmail(String title, String content);
}
```

위와 같이 추상 메서드는 **몸통 없이 이름, 매개변수 타입, 결과 타입만 작성된 메서드**다.
타입 검사기가 원하는 정보인 메서드 이름, 매개변수 타입, 결과 타입을 제공하는 것이다.

