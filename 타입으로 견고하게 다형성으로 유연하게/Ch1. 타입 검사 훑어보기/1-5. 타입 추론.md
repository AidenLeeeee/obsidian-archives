정적 타입 언어에는 여러 장점이 존재하지만, 개발자가 직접 변수나 함수의 타입을 제공해야 한다는 점은 여전히 불편한 점으로 남는다.
따라서 여러 언어는 개발자의 타입 표시 없이도 타입 검사를 할 수 있도록 **타입 추론** 기능을 제공한다.

물론 타입을 명시할 경우에는 코드에 더 많은 정보를 제공할 수 있다는 장점이 존재하긴 하지만 타입의 이름이 지나치게 길면 코드가 장황해진다는 점, 코드를 작성할 때마다 타입을 명시해야 하므로 생산성이 떨어진다는 단점도 존재한다.

## 타입 추론

타입을 모두 작성하기 귀찮거나, 타입 표시를 생략하고 싶을 떄 개발자가 타입 표시를 생략할 수 있도록 하는 기능을 타입 추론 기능이라 한다.

#### 변수의 타입

가장 간단한 형태의 타입 추론은 변수의 타입을 알아내는 것이다.
대부분의 정적 타입 언어는 이 기능을 제공한다.

아래와 같이 변수가 정의될 때 초깃값이 주어진다면 타입 검사기는 변수의 타입을 쉽게 찾을 수 있다.

```javascript
var num = 1 + 2;
```

위 코드에서 개발자는 `num` 변수에 대한 타입을 제공하지 않았지만 타입 검사기는 `1 + 2` 라는 정보만을 가지고도 `num` 변수에 대한 타입을 `Int` 로 결론지을 수 있는 것이다.

#### 함수의 타입

변수와 달리, 함수의 타입 표시를 생략하면 타입 추론이 쉽지 않다.
함수의 Body 를 검사하려면 매개변수의 타입을 알아야 하기 때문이다.

따라서 대부분의 언어에서는 아주 제한적인 경우에만 함수의 타입 표시를 생략할 수 있다.

#### 타입 추론에 대한 오해

타입 추론은 개발자가 타입 표시를 생략해 코드를 간결하게 만드는 데 도움이 된다.
타입을 표시하는 번거로운 일을 줄이고, 생략된 타입 표시를 타입 검사기가 스스로 알아내기 때문이다.
그러니 타입을 표시하지 않고도 타입 검사기가 제공하던 혜택을 모두 받을 수 있다.

하지만 타입 추론이 타입 검사의 결과에 영향을 주지는 않는다.
어디까지나 타입 표시를 생략할 수 있게 할 뿐이다.

```typescript
function readFile(file, isString: boolean): string {
	if (isString) {
		const fileName: string = file;
		...
	} else {
		const filePath: path = file;
		...
	}
}
```

위 코드에서 `isString` 이 `true` 라면 `file` 의 타입을 문자열로 사용하고,
`isString` 이 `false` 라면 `file` 의 타입을 `path` 로 사용한다.
즉, 첫 번째 매개변수인 `file` 의 타입을 `string` 이라고 해도 틀리고, `path` 라고 해도 틀리는 것이다.
따라서 타입 검사기가 스스로 타입을 추론할 수 있도록 `file` 에 대한 타입 표시를 생략했다.

하지만 이와 같은 꼼수는 통하지 않는다.
타입 추론은 생략된 타입 표시를 복구할 뿐이다. 타입 표시를 생략하는 것이지, 타입 검사를 생략한게 아닌 것이다.
따라서 타입 검사기는 생략된 매개변수 타입에 해당하는 타입을 찾을 수 없게 되고, '거부' 를 출력한다.

이처럼 **타입 추론은 검사를 통과하지 못하던 프로그램이 검사를 통과할 수 있게 해주는 기능이 아니다.**
타입 표시가 있을 때도 검사를 통과할 프로그램에 한해 타입 표시를 생략할 수 있게 해줄 뿐이다.