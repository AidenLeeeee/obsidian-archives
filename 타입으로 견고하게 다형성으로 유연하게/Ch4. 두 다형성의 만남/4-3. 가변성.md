가변성(variance)은 제네릭 타입 사이의 서브타입 관계를 추가로 정의하는 기능이다.

상속이 List 와 ArrayList 처럼 서로 다른 제네릭 타입 사이의 서브타입 관계를 만든다면, 가변성은 하나의 제네릭 타입에서 타입 인자만 다르게 하여 얻은 타입들 사이의 서브타입 관계를 만든다.

아래는 사람들의 평균 나이를 계산하는 함수이다.

```java
Int averageAge(List<Person> people) {
	people.length() ...
	people.get(i).age ...
}
```

averageAge 에 Person 타입의 리스트를 인자로 넘기는 데는 아무 문제도 없다.
하지만 학생의 리스트를 averageAge 의 인자로 사용하여 학생들의 평균 나이를 구하려고 하면 문제가 발생한다.

```java
List<Student> students = ...;
averageAge(students);
```

그 이유는 `List<Person>` 타입과 `List<Student>` 타입은 서브타입도 아닌, 완전히 다른 타입이기 때문이다.

하지만 이는 만족스럽지 않은 결과이다.
averageAge 는 주어진 리스트의 각 원소의 age 필드를 읽을 뿐이므로, 실행 중에 오류가 발생할 리 없기 때문이다.

이를 위한 해결방법은 아래와 같다.

```java
Int averageAge<T <: Person>(List<T> people) { ... }
averageAge<Student>(students);
```

averageAge 는 타입 매개변수 T 를 가진다. T 의 상한은 Person 이며 averageAge 의 매개변수 타입은 `List<T>` 이다.
Student 가 Person 의 서브타입이기 때문에 타입 매개변수 T 에 Student 를 인자로 넣으며 호출하면 정상적으로 타입 검사를 통과할 수 있다.

물론, 이 방법은 문제를 해결하는 좋은 방법이지만 아쉬운 점이 있다.
우리는 앞으로 `List<A>` 타입의 인자를 받는 함수를 정의할 때마다 매개변수 타입을 `List<A>` 로 하는 대신, 상한이 A인 타입 매개변수 T를 정의하고 매개변수 타입을 `List<A>` 로 해야 한다.
그래야 B 가 A 의 서브타입일 때 그 함수가 `List<B>` 타입의 리스트도 인자로 받을 수 있다.
이는 꽤나 귀찮은 일이다.

직관적으로, Student 가 Person 의 서브타입이기 때문에 `List<Student>` 도 `List<Person>` 의 서브타입이 될 수 있다면, 이 문제를 더욱 쉽게 해결할 수 있을 것이다.
이렇게 하면 굳이 averageAge 를 제네릭 함수로 만들 필요 없이 `List<Person>` 을 매개변수 타입으로 사용할 수 있을 것이다.

하지만 이를 위해서는 한 가지 고려해야 할 것이 있다.
과연 B 가 A 의 서브타입일 때 `List<B>` 가 `List<A>` 의 서브타입이 되어도 될까?
결론은 그럴 수도 있고 아닐 수도 있다는 것이다.

### 예시

List1 은 가장 기본적인 기능을 제공하는 리스트다.
오직 담겨 있는 원소들을 알려 줄 뿐, 원소를 직접 추가하거나 제거할 수는 없는 리스트이다.

```java
abstract class List1<T> {
	T get(Int idx);
}
```

List1 은 메서드 하나만 가진다. 메서드 get 은 정수를 인자로 받아 해당 위치의 원소를 반환한다.

과연 위 `List1<Student>` 이 `List1<Person>` 의 서브타입이어도 될까?
서브타입임을 가정하고 아래 예시를 보자.

```java
List1<Student> students = ...;
List1<Person> people = students;
```

students 는 `List1<Student>` 타입의 리스트이다. `List1<Student>` 가 `List1<Person>` 의 서브타입이기 때문에 students 를 people 에 할당할 수 있다. 그러면 people 은 타입만 `List1<Person>` 이고 실제로는 학생으로만 구성된 리스트가 된다.

```java
Person p = people.get(...);
p.age ...
```

이제 List1 의 메서드인 get 을 사용해 people 의 원소를 얻을 수 있고, 이를 변수 p 에 저장했다.
타입 검사기의 입장에서는 people 의 타입이 `List1<Person>` 이기 때문에 p 의 타입이 Person 이다. 따라서 p 를 Person 타입의 객체로서 사용하는 것을 허락한다.
물론, 실행 중에는 people 이 학생으로만 구성된 리스트이므로 get 을 통해 얻은 값이 학생 객체일 것이다.
하지만 Student 가 Person 을 상속했으므로 학생 객체를 사람 객체처럼 사용해도 문제가 없다.

정리하면, 학생의 리스트를 사람의 리스트로 취급함으로써 발생할 수 있는 일은 사람 객체를 기대한 곳에서 학생 객체가 나오는 것 뿐이다. 따라서 이는 프로그램에 어떠한 해도 끼치지 않는다.
즉, `List1<Student>` 가 `List1<Person>` 의 서브타입이어도 괜찮다.

### 예시 2

List2 는 List1 보다 더 많은 기능을 제공한다. 들어 있는 원소들을 알려 줄 뿐 아니라 새 원소를 추가하는 것 역시 허용한다.

```java
abstract class List2<T> {
	T get(Int idx);
	Void add(T t);
}
```

이번에는 `List2<Student>` 가 `List2<Person>` 의 서브타입이어도 되는지 살펴볼 차례다.

```java
List2<Student> students = ...;
List2<Person> people = students;
```

students 는 `List2<Student>` 타입의 리스트이다.
people 은 타입만 `List2<Person>` 일 뿐, students 와 동일한 리스트를 가리킨다.

이제 List2 에 add 메서드를 사용하여 people 에 원소를 추가해보자.
people 의 타입이 `List2<Person>` 이기에 타입 검사기가 사람 객체를 추가하는 것을 허용할 것이다.
문제는 students 와 people 이 같은 리스트를 나타낸다는 것이다.
people 에 사람 객체를 추가하는 것은 곧 students 에 사람 객체를 추가한 것과 같은 것이다.
따라서 `List2<Student>` 타입의 리스트인 students 에 이제 학생이 아닌 사람도 들어 있게 된다.

```java
Student s = students.get(...);
s.gpa ...
```

타입 검사기의 입장에서 students 의 타입은 변함없이 `List2<Student>` 이다. 따라서 get 을 통해 얻은 값의 타입이 Student 라고 판단하며, 그 값을 학생 객체로서 사용하는 것을 허락한다.

사령 사람 객체에는 없지만 학생 객체에는 있는 gpa 필드를 읽는 경우가 발생할 수 있는데, 문제는 실행 중에 students 에서 get 을 통해 얻은 값이 사람 객체인 경우이다.

이전에 리스트에 사람 객체를 추가했기 때문에 get 의 결과가 학생 객체가 아니라 사람 객체일 수 있다.
이 경우 gpa 필드를 읽으려 하면 실행 중에 오류가 발생할 것이다.
타입 검사를 통과한 코드가 오류를 일으킨 것이다.
이는 타입 검사기의 타입 안정성을 깨트리는 치명적인 문제다.
`List2<Student>` 가 `List2<Person>` 의 서브타입이라고 가정한 것만으로도 이러한 오류가 발생할 수 있는 것이다.

따라서 `List2<Student>` 가 `List2<Person>` 의 서브타입이면 안된다.

### 공변, 불변, 반변

지금까지의 내용으로 알 수 있는 사실은 "어떤 제네릭 타입은 타입 인자의 서브타입 관계를 보존하지만, 어떤 제네릭 타입은 그렇지 않다" 라는 것이다. 그러므로 제네릭 타입과 타입 인자 사이의 관계를 분류할 수 있다. 이 분류를 **가변성**이라고 부른다.
다시 말해 가변성이란 제네릭 타입과 타입 인자 사이의 관계를 뜻한다.
그리고 우리의 관찰 결과 적어도 두 가지 가변성이 존재함을 알 수 있다.

첫 번째 가변성은 제네릭 타입이 타입 인자의 서브타입 관계를 보존하는 것이다.
List1 이 여기에 해당한다.
B 가 A 의 서브타입일 때 `List1<B>` 가 `List1<A>` 의 서브타입이다.
약간 다르게 표현하면, 타입 인자가 A 에서 서브타입인 B 로 변할 때 `List1<A>` 역시 서브타입인 `List<B>` 로 변한다고 말할 수 있다.
따라서 제네릭 타입이 타입 인자와 "함께 변한다"는 뜻을 담아, 이런 가변성을 **공변(Covariance)** 이라고 부른다.

두 번째 가변성은 제네릭 타입이 타입 인자의 서브타입 관계를 무시하는 것이다.
List2 가 이런 경우다.
B 가 A 의 서브타입이더라도 `List2<B>` 와 `List2<A>` 사이에는 아무런 관계가 없다.
`List2<B>` 와 `List2<A>` 가 완전히 다른 타입인 것이다.
다시 말해 타입 인자가 A 에서 서브타입인 B 로 변할 때 `List2<A>` 는 그냥 다른 타입인 `List2<B>` 가 될 뿐이지, 서브타입으로 변하는 것은 아니다.
따라서 타입 인자가 서브타입으로 변해도 제네릭 타입은 서브타입으로 "변하지 않는다"는 뜻으로 이런 가변성을 **불변(Invariance)** 이라 부른다.

추가로 세 번째 가변성도 함수 타입 안에 존재한다.
함수 타입 T => S 는 두 개의 타입 매개변수를 가진 제네릭 타입이다.
함수 타입은 매개변수 타입의 서브타입 관계를 뒤집고 결과 타입의 서브타입 관계를 유지하는데, 함수 타입과 결과 타입 사이의 관계는 공변이라는 의미로 해석할 수 있다.

한편, 함수 타입과 매개변수 타입 사이의 관계는 공변도 불변도 아니다.
바로 여기서 세 번째 가변성이 등장한다.

세 번째 가변성은 제네릭 타입이 타입 인자의 서브타입 관계를 뒤집는 것이다.
즉, 결과 타입을 C 로 고정할 때 B 가 A 의 서브타입이면 B => C 는 A => C 의 슈퍼타입이다.
따라서 이런 가변성을 **반변(Contravariance)** 이라고 부른다.

### 정리

지금까지 알아본 내용을 통해 공변, 불변, 반변을 파악하기 위한 방법은 아래와 같다.

제네릭 타입을 G, 타입 매개변수의 이름을 T 라고 했을 때,
G 가 T 를 출력에만 사용하면 공변, 입력에만 사용하면 반변, 출력과 입력에 모두 사용하면 불변이다.

G 가 T 를 출력한다는 것은 메서드의 결과 타입이 T 라는 의미이다.
반대로 T 를 입력에만 사용한다는 것은 메서드의 매개변수 타입이 T 임을 의미한다.

List1 이 get 메서드만을 가지고 있고, 결과 타입이 T 였던 것을 생각해보면, T 를 출력에는 사용하고 입력에는 사용하지 않았으므로, 공변임을 알 수 있다.

한편 List2 에서는 get 뿐 아니라, add 메서드를 통해 T 를 입력으로 사용한다는 것을 알 수 있다.
따라서 T 를 입력과 출력에 모두 사용했으므로 불변이라고 할 수 있다.

추가로 T => Int 와 같은 함수는 T 를 입력에만 사용했으므로, 반변이라고 할 수 있다.

### 가변성의 지정

타입 검사기의 가변성 판단 방법은 두 가지가 있다.

하나는 개발자가 제네릭 타입을 정의할 때 가변성을 지정(declaration-site variance)하는 방법이고, 다른 하나는 사용할 때 가변성을 지정(use-site variance)하는 방법이다.

언어마다 사용하는 방법이 다르고, 두 가지 방법을 모두 사용할 수도 있다.

#### 정의할 때 가변성 지정하기

가변성은 각 제네릭 타입의 고유한 속성이기 때문에 정의할 때 가변성을 지정하는 게 가장 직관적이다.
개발자는 제네릭 타입의 각 타입 매개변수에 가변성을 표시하여 공변, 반변, 불변 중 하나를 고를 수 있다.
아무런 표시도 하지 않을 경우 기본으로 불변이 선택된다.

1. 공변
특정 타입 매개변수를 공변으로 만들기 위해서는 타입 매개변수 앞에 out 을 붙여야 한다.
out 은 해당 타입 매개변수가 출력에만 사용됨을 뜻한다.

```java
abstract class ReadOnlyList<out T> {
	Int length();
	T get(Int idx);
}
```

이제 T 를 메서드 결과 타입으로 사용할 수는 있어도 매개변수 타입으로 사용할 수는 없다.

2. 반변
타입 매개변수를 반변으로 만들고 싶을 때는 out 대신 in 을 붙인다.

```java
abstract class Map<in T, S> {
	Int size();
	S get(T t);
	Void add(T t, S s);
}
```

Map 클래스는 T 와 S 두 개의 타입 매개변수를 가진다.
여기서 T 는 get 과 add 에서 입력으로만 사용되었기 때문에 반변으로 정의할 수 있다.

반면 S 는 get 에서는 출력, add 에서는 입력에 사용되었으므로 반드시 불변이어야 한다.

위와 같은 방법은 직관적이라는 장점이 있지만, 클래스를 정의할 때 큰 제약이 생긴다는 문제가 있다.
타입을 공변으로 만든다면 타입 매개변수를 입력에 사용할 수 없고, 반변으로 만든다면 마찬가지로 나머지 절반을 포기해야 하는 것이다.
물론 불변을 선택하면 아무 메서드나 정의할 수 있지만, 서브타입 관계가 추가로 만들어지지 않아 멀쩡한 코드인데도 타입 검사를 통과하지 못하는 경우가 생긴다.

#### 사용할 때 가변성 지정하기

위와 같은 문제를 위해 제네릭 타입을 사용할 때 가변성을 지정하도록 미룰 수 있다.
만약 제네릭 타입을 사용할 때 가변성을 지정하는 경우, 제네릭 타입을 정의할 때는 가변성을 지정할 수 없다.

기본적으로 모든 제네릭 타입은 불변으로 정의되며 타입 매개변수를 아무 데서나 사용할 수 있다. 따라서 제약없이 제네릭 타입을 만들 수 있다는 장점이 있다.

제네릭 타입을 사용할 때 가변성을 불변 대신 공변이나 반변으로 지정하려면 새로운 종류의 타입을 사용해야 한다.
새로운 종류의 타입들은 타입 인자 앞에 out 또는 in 을 붙여 만들 수 있다.

1. 공변
제네릭 타입을 공변으로 만들기 위해서는, 사용할 때 타입 인자의 앞에 out 을 붙여야 한다.

```java
List<out Person> people = ...;
people.length();
people.get(...);
```

이 경우, 출력 기능만 사용 가능하다.
따라서 아래 코드는 타입 검사를 통과하지 못한다.

```java
people.add(...);
```

이제 B 가 A 의 서브타입일 때, `List<out B>` 는 `List<out A>` 의 서브타입이다.
또한 "C 는 B 이고, B 는 A 일 때, C 는 A 다" 라는 명제가 참이기 때문에 `List<B>` 역시 `List<out A>` 의 서브타입이 될 수 있다.
`List<A>` 는 `List<out A>` 의 서브타입이기 때문이다.

2. 반변
반대로 제네릭 타입을 반변으로 만들기 위해서는, 사용할 때 타입 인자의 앞에 in 을 붙이면 된다.

```java
List<in Person> people = ...;
people.length();
people.add(...);
```

이 경우, 입력 기능만 사용 가능하기 때문에 아래 코드는 타입 검사를 통과하지 못한다.

```java
people.get(...);
```

반변에서는 서브타입 관계가 뒤집히기 때문에 B 가 A 의 서브타입일 때 `List<in A>` 가 `List<in B>` 의 서브타입이다.
마찬가지로, 연쇄 작용에 의해 B 가 A 의 서브타입일 때 `List<A>` 가 `List<in B>` 의 서브타입이라는 사실까지 성립한다.

이렇게, 제네릭 타입을 사용할 때 가변성을 지정하면 제네릭 타입을 자유롭게 정의할 수 있다.
제네릭 타입을 정의할 때 가변성을 지정하면 생기는 문제점을 말끔히 해결한 것이다.

또한 공변이나 반변이 필요한 경우, 타입 인자에 out 이나 in 을 붙이기만 하면 되니 원하는 가변성을 선택하기도 쉽다.