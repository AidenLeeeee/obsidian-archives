가변성(variance)은 제네릭 타입 사이의 서브타입 관계를 추가로 정의하는 기능이다.

상속이 List 와 ArrayList 처럼 서로 다른 제네릭 타입 사이의 서브타입 관계를 만든다면, 가변성은 하나의 제네릭 타입에서 타입 인자만 다르게 하여 얻은 타입들 사이의 서브타입 관계를 만든다.

아래는 사람들의 평균 나이를 계산하는 함수이다.

```java
Int averageAge(List<Person> people) {
	people.length() ...
	people.get(i).age ...
}
```

averageAge 에 Person 타입의 리스트를 인자로 넘기는 데는 아무 문제도 없다.
하지만 학생의 리스트를 averageAge 의 인자로 사용하여 학생들의 평균 나이를 구하려고 하면 문제가 발생한다.

```java
List<Student> students = ...;
averageAge(students);
```

그 이유는 `List<Person>` 타입과 `List<Student>` 타입은 서브타입도 아닌, 완전히 다른 타입이기 때문이다.

하지만 이는 만족스럽지 않은 결과이다.
averageAge 는 주어진 리스트의 각 원소의 age 필드를 읽을 뿐이므로, 실행 중에 오류가 발생할 리 없기 때문이다.

이를 위한 해결방법은 아래와 같다.

```java
Int averageAge<T <: Person>(List<T> people) { ... }
averageAge<Student>(students);
```

averageAge 는 타입 매개변수 T 를 가진다. T 의 상한은 Person 이며 averageAge 의 매개변수 타입은 `List<T>` 이다.
Student 가 Person 의 서브타입이기 때문에 타입 매개변수 T 에 Student 를 인자로 넣으며 호출하면 정상적으로 타입 검사를 통과할 수 있다.

물론, 이 방법은 문제를 해결하는 좋은 방법이지만 아쉬운 점이 있다.
우리는 앞으로 `List<A>` 타입의 인자를 받는 함수를 정의할 때마다 매개변수 타입을 `List<A>` 로 하는 대신, 상한이 A인 타입 매개변수 T를 정의하고 매개변수 타입을 `List<A>` 로 해야 한다.
그래야 B 가 A 의 서브타입일 때 그 함수가 `List<B>` 타입의 리스트도 인자로 받을 수 있다.
이는 꽤나 귀찮은 일이다.

직관적으로, Student 가 Person 의 서브타입이기 때문에 `List<Student>` 도 `List<Person>` 의 서브타입이 될 수 있다면, 이 문제를 더욱 쉽게 해결할 수 있을 것이다.
이렇게 하면 굳이 averageAge 를 제네릭 함수로 만들 필요 없이 `List<Person>` 을 매개변수 타입으로 사용할 수 있을 것이다.

하지만 이를 위해서는 한 가지 고려해야 할 것이 있다.
과연 B 가 A 의 서브타입일 때 `List<B>` 가 `List<A>` 의 서브타입이 되어도 될까?
결론은 그럴 수도 있고 아닐 수도 있다는 것이다.

### 예시

List1 은 가장 기본적인 기능을 제공하는 리스트다.
오직 담겨 있는 원소들을 알려 줄 뿐, 원소를 직접 추가하거나 제거할 수는 없는 리스트이다.

```java
abstract class List1<T> {
	T get(Int idx);
}
```

List1 은 메서드 하나만 가진다. 메서드 get 은 정수를 인자로 받아 해당 위치의 원소를 반환한다.

과연 위 `List1<Student>` 이 `List1<Person>` 의 서브타입이어도 될까?
서브타입임을 가정하고 아래 예시를 보자.

```java
List1<Student> students = ...;
List1<Person> people = students;
```

students 는 `List1<Student>` 타입의 리스트이다. `List1<Student>` 가 `List1<Person>` 의 서브타입이기 때문에 students 를 people 에 할당할 수 있다. 그러면 people 은 타입만 `List1<Person>` 이고 실제로는 학생으로만 구성된 리스트가 된다.

```java
Person p = people.get(...);
p.age ...
```

이제 List1 의 메서드인 get 을 사용해 people 의 원소를 얻을 수 있고, 이를 변수 p 에 저장했다.
타입 검사기의 입장에서는 people 의 타입이 `List1<Person>` 이기 때문에 p 의 타입이 Person 이다. 따라서 p 를 Person 타입의 객체로서 사용하는 것을 허락한다.
물론, 실행 중에는 people 이 학생으로만 구성된 리스트이므로 get 을 통해 얻은 값이 학생 객체일 것이다.
하지만 Student 가 Person 을 상속했으므로 학생 객체를 사람 객체처럼 사용해도 문제가 없다.

정리하면, 학생의 리스트를 사람의 리스트로 취급함으로써 발생할 수 있는 일은 사람 객체를 기대한 곳에서 학생 객체가 나오는 것 뿐이다. 따라서 이는 프로그램에 어떠한 해도 끼치지 않는다.
즉, `List1<Student>` 가 `List1<Person>` 의 서브타입이어도 괜찮다.

### 예시 2

List2 는 List1 보다 더 많은 기능을 제공한다. 들어 있는 원소들을 알려 줄 뿐 아니라 새 원소를 추가하는 것 역시 허용한다.

```java
abstract class List2<T> {
	T get(Int idx);
	Void add(T t);
}
```

이번에는 `List2<Student>` 가 `List2<Person>` 의 서브타입이어도 되는지 살펴볼 차례다.

```java
List2<Student> students = ...;
List2<Person> people = students;
```

students 는 `List2<Student>` 타입의 리스트이다.
people 은 타입만 `List2<Person>` 일 뿐, students 와 동일한 리스트를 가리킨다.

이제 List2 에 add 메서드를 사용하여 people 에 원소를 추가해보자.
people 의 타입이 `List2<Person>` 이기에 타입 검사기가 사람 객체를 추가하는 것을 허용할 것이다.
문제는 students 와 people 이 같은 리스트를 나타낸다는 것이다.
people 에 사람 객체를 추가하는 것은 곧 students 에 사람 객체를 추가한 것과 같은 것이다.
따라서 `List2<Student>` 타입의 리스트인 students 에 이제 학생이 아닌 사람도 들어 있게 된다.

```java
Student s = students.get(...);
s.gpa ...
```

타입 검사기의 입장에서 students 의 타입은 변함없이 `List2<Student>` 이다. 따라서 get 을 통해 얻은 값의 타입이 Student 라고 판단하며, 그 값을 학생 객체로서 사용하는 것을 허락한다.

사령 사람 객체에는 없지만 학생 객체에는 있는 gpa 필드를 읽는 경우가 발생할 수 있는데, 문제는 실행 중에 students 에서 get 을 통해 얻은 값이 사람 객체인 경우이다.

이전에 리스트에 사람 객체를 추가했기 때문에 get 의 결과가 학생 객체가 아니라 사람 객체일 수 있다.
이 경우 gpa 필드를 읽으려 하면 실행 중에 오류가 발생할 것이다.
타입 검사를 통과한 코드가 오류를 일으킨 것이다.
이는 타입 검사기의 타입 안정성을 깨트리는 치명적인 문제다.
`List2<Student>` 가 `List2<Person>` 의 서브타입이라고 가정한 것만으로도 이러한 오류가 발생할 수 있는 것이다.

따라서 `List2<Student>` 가 `List2<Person>` 의 서브타입이면 안된다.

### 정리

지금까지의 내용으로 알 수 있는 사실은 "어떤 제네릭 타입은 타입 인자의 서브타입 관계를 보존하지만, 어떤 제네릭 타입은 그렇지 않다" 라는 것이다. 그러므로 제네릭 타입과 타입 인자 사이의 관계를 분류할 수 있다. 이 분류를 **가변성**이라고 부른다.
다시 말해 가변성이란 제네릭 타입과 타입 인자 사이의 관계를 뜻한다.
그리고 우리의 관찰 결과 적어도 두 가지 가변성이 존재함을 알 수 있다.

첫 번째 가변성은 제네릭 타입이 타입 인자의 서브타입 관계를 보존하는 것이다.
List1 이 여기에 해당한다.
B 가 A 의 서브타입일 때 `List1<B>` 가 `List1<A>` 의 서브타입이다.
약간 다르게 표현하면, 타입 인자가 A 에서 서브타입인 B 로 변할 때 `List1<A>` 역시 서브타입인 `List<B>` 로 변한다고 말할 수 있다.
따라서 제네릭 타입이 타입 인자와 "함께 변한다"는 뜻을 담아, 이런 가변성을 **공변(Covariance)** 이라고 부른다.

두 번째 가변성은 제네릭 타입이 타입 인자의 서브타입 관계를 무시하는 것이다.
List2 가 이런 경우다.
B 가 A 의 서브타입이더라도 `List2<B>` 와 `List2<A>` 사이에는 아무런 관계가 없다.
`List2<B>` 와 `List2<A>` 가 완전히 다른 타입인 것이다.
다시 말해 타입 인자가 A 에서 서브타입인 B 로 변할 때 `List2<A>` 는 그냥 다른 타입인 `List2<B>` 가 될 뿐이지, 서브타입으로 변하는 것은 아니다.
따라서 타입 인자가 서브타입으로 변해도 제네릭 타입은 서브타입으로 "변하지 않는다"는 뜻으로 이런 가변성을 **불변(Invariance)** 이라 부른다.

추가로 세 번째 가변성도 함수 타입 안에 존재한다.
함수 타입 T => S 는 두 개의 타입 매개변수를 가진 제네릭 타입이다.
함수 타입은 매개변수 타입의 서브타입 관계를 뒤집고 결과 타입의 서브타입 관계를 유지하는데, 함수 타입과 결과 타입 사이의 관계는 공변이라는 의미로 해석할 수 있다.

한편, 함수 타입과 매개변수 타입 사이의 관계는 공변도 불변도 아니다.
바로 여기서 세 번째 가변성이 등장한다.

세 번째 가변성은 제네릭 타입이 타입 인자의 서브타입 관계를 뒤집는 것이다.
즉, 결과 타입을 C 로 고정할 때 B 가 A 의 서브타입이면 B => C 는 A => C 의 슈퍼타입이다.
따라서 이런 가변성을 **반변(Contravariance)** 이라고 부른다.