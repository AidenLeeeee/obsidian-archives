## 존재 양화 타입의 활용

#### 문제

```java
class Timestamper {
	Int init() { return 0; }
	Int next(Int t) { return t + 1; }
	Bool cmp(Int t1, Int t2) { return t1 < t2; }
}
```

위 클래스의 용도는 타임스탬프를 발급하는 것이다.
- init() 메서드는 최초의 타임스탬프를 발급한다. 그 값은 0이 된다.
- 그 다음 타임스탬프를 얻으려면 next() 메서드를 호출해야 한다.
  0을 넘기면 그 다음 타임스탬프인 1이 나오고, 1을 넘기면 2가 나온다.
- cmp() 메서드는 두 타임스탬프를 비교해 어느 것이 먼저인지 알려준다.

이제 ts 가 타임스탬프를 저장하는 리스트라고 할 때, 아래와 같이 Timestamper 클래스를 사용할 수 있을 것이다.

```java
Timestamper t = Timestamper();
List<Int> ts = ...;
ts[a] = t.init();
...
ts[b] = t.next();
...
if (t.cmp(ts[d], ts[e])) { ... }
```

이제 우리는 Timestamper 를 라이브러리로 제공하려고 한다.
그렇다면 라이브러리에는 Timestamper 클래스의 정의와 Timestamper 객체를 만드는 create 함수가 정의되어야 할 것이다.

```java
class Timestamper { ... }
Timestamper create() { return Timestamper(); }
```

라이브러리 사용자는 Timestamper 객체를 직접 만들지는 못하고 create 함수를 호출할 수만 있다.
따라서 라이브러리를 사용할 때는 아래와 같이 코드를 작성해야 한다.

```java
Timestamper t = create();
```

물론 지금까지의 구현만으로도 실행은 잘되지만 타입스탬프의 타입인 Int 가 라이브러리를 사용하는 쪽에 공개되어 있다는 점이 아쉬운 점이다.
이로 인해 라이브러리 사용자가 타임스탬프의 타입이 Int 라는 사실을 이용하는 코드를 작성할 수도 있기 때문이다.

```java
...
if (ts[d] < ts[e]) { ... }
```

위 코드에서는 라이브러리 사용자가 cmp 메서드의 존재를 망각하고 < 를 직접 사용하여 타임스탬프를 비교했다. 물론 여기까지는 아무런 문제도 발생하지 않지만, 라이브러리를 이후에 수정할 때 제약이 발생한다.

만약 아래와 같이 Timestamper 클래스를 수정했다고 하자.

```java
class Timestamper {
	Int init() { return 0; }
	Int next(Int t) { return t - 1; }
	Bool cmp(Int t1, Int t2) { return t1 > t2; }
}
```

- next() 메서드의 정의가 바뀌었다.
  이제 다음 타임스탬프를 만들 때 1을 더하지 않고 1을 뺀다.
  따라서 이에 맞춰 cmp() 메서드 역시 수정되어야 한다.
- cmp() 메서드는 이제 t1 < t2 대신 t1 > t2 를 계산하여 반환한다.

이제 사용자가 라이브러리 내부의 함수를 사용하지 않고, 직접 타임스탬프 값을 비교한 경우, 결과값은 완전히 뒤바뀌게 될 것이다.
결국 타임스탬프 간 선후 관계를 잘못 파악하게 되어 프로그램의 동작이 달라지는 것이다.

만약 사용자가 라이브러리 내부의 next() 와 cmp() 메서드만을 애플리케이션 내부에서 사용하고 있다면 이런 위험은 없을 것이다.

이처럼 Int 라는 타임스탬프의 타입이 라이브러리 사용자에게 노출되는 것은 라이브러리를 만드는 입장에서 바람직하지 않다.
라이브러리 사용자의 코드가 타임스탬프를 Int 로 사용했는데 라이브러리 코드를 고치면, 프로그램의 동작이 달라지거나 아예 타입 검사를 통과하지 못하게 될 수 있는 것이다.
따라서 라이브러리 구현을 수정하고 싶어도 함부로 수정할 수 없게 된다는 문제가 생긴다.

#### 존재 양화 타입 활용한 해결

이를 해결하려면 타임스탬프의 타입을 라이브러리 사용자에게 숨겨야 한다.
타임스탬프의 타입이 Int 임을 알려 주는 대신 타임스탬프의 타입이 되는 '무엇인가'가 존재한다고만 알려주는 것이다. 그리고 그 '무엇인가'는 Int 일 수도 있고, String 일 수도 있다.
즉, 라이브러리를 만들고 수정할 우리가 언제든지 바꿀 수 있는 타입인 것이다.

이제 사용자는 타임스탬프의 타입이 되는 '무엇인가'가 존재한다는 사실은 알고 있지만, 그 타입이 특정한 타입이라는 기대를 가지고 코드를 작성할 수는 없다.
따라서 사용자가 라이브러리의 특정 타입에서 힌트를 얻어 내부 함수를 사용하지 않고 직접 값을 조작하고 생성하고 비교하는 작업을 수행할 수 없는 것이다.

존재 양화 타입을 사용하면 라이브러리를 아래와 같이 다시 작성할 수 있다.

```java
class Timestamper {
	Int init() { return 0; }
	Int next(Int t) { return t + 1; }
	Bool cmp(Int t1, Int t2) { return t1 < t2; }
}
exists T.{ T init(); T next(T t); Bool cmp(T t1, T t2); } create() {
	return Timestamper();
}
```

이제 create 의 결과 타입이 `exists T.{ T init(); T next(T t); Bool cmp(T t1, T t2); }` 가 되었다.
이렇게 exists T.A 형태(T 는 타입 매개변수, A는 타입)로 생긴 타입이 존재 양화 타입이다.
이 타입은 create 가 반환하는 값의 타입이 `{ T init(); T next(T t); Bool cmp(T t1, T t2); }` 의 형태라는 것을 표현한다. 여기서 T 가 무엇인지는 알 수 없다.

이제 create 가 반환하는 값은 Timestamper 객체이고, 이 객체의 타입은 `{ Int init(); Int next(Int t); Bool cmp(Int t1, Int t2); }` 이다.
그렇다면 T 가 Int 일 때 이 객체의 타입이 `{ T init(); T next(T t); Bool cmp(T t1, T t2); }` 라고 해도 올바른 타입 명시일 것이다.
물론, 문자열을 타임스탬프로 사용하도록 수정해도 타임 겁사를 통과할 수 있다.

이제 라이브러리 사용자의 코드를 다시 살펴보자.

```java
exists T.{ T init(); T next(T t); Bool cmp(T t1, T t2); } t = create();
List<t.T> ts = ...;
...
if (ts[d] < ts[e]) { ... }
```

이제 라이브러리 사용자가 임의로 타임스탬프를 비교하는 위 코드는 타임 검사를 통과하지 못할 것이다.
`ts[d]`와 `ts[e]` 의 타입은 타임스탬프 타입으로, 이 타입에 해당하는 '무엇인가'가 존재한다는 사실만 알 수 있을 뿐, 실제로 Int 타입인지는 알 수 없기 때문이다.
결국 라이브러리 사용자는 타임스탬프 선후 관계 비교에 cmp() 를 사용할 수 밖에 없다.

```java
exists T.{ T init(); T next(T t); Bool cmp(T t1, T t2); } t = create();
List<t.T> ts = ...;
...
if (t.cmp(ts[d], ts[e])) { ... }
```

추가적으로 라이브러리 사용자가 타임스탬프의 타입을 표현한 방법을 보면, ts 의 타입이 List<t.T> 인 것을 알 수 있는데, 이는 변수 t 가 숨기고 있는 어떤 타입 T 라는 뜻이다.

## 요약

이렇게 존재 양화 타입은 기존의 정적 타입 언어가 제공하는 다른 대부분의 기능과는 다른 목적을 가지고 있다.
기존의 정적 타입 언어가 제공하는 기능의 대부분이 타입 검사를 통과할 수 없는 프로그램이 타입 검사를 통과할 수 있도록 돕는 데 목적이 있었다면, 존재 양화 타입의 목적은 **타입 검사를 통과할 수 있는 프로그램이 타입 검사를 통과할 수 없도록 만드는 데 목적**이 있기 때문이다.

하지만 라이브러리를 만드는 상황처럼, 특정 사용자의 타입을 활용한 어떤 코드나 행위를 제약하기 위해서는 위와 같은 기능이 중요하다.