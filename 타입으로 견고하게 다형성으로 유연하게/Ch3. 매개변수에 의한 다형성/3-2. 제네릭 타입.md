
타입 매개변수는 함수 이외에 타입에도 적용할 수 있다.
타입에 타입 매개변수를 추가하면 제네릭 타입(generic type)이 된다.

### 제네릭 타입의 활용

예를 들어 아래와 같이 각각의 원소가 Int 타입인 List 타입이 있을 때, 이 값의 타입을 List 로만 정의하면 어떤 함수에서는 문제가 발생할 수 있다.

```
List integers = List(1, 2, 3, 4, 5);
List countries = List("Korea", "Japan", "China");
```

```
Int sum(List list) {
	Int res = 0;
	for (Int i = 0; i < list.length; i++) {
		res = res + list[i];
	}
	return res;
}
```

```
sum(countries);
```

sum 함수는 리스트 내 각각의 원소의 합을 구하는 함수인데, 인자의 타입을 List 로만 표현하다보니 문자열 List 값이 인자로 들어올 수도 있기 때문이다.

따라서 우리는 이와 같이 List 타입의 인자를 받는 함수를 정의할 때, 각 원소의 타입을 정확하게 표현해주어야 한다.

바로 이러한 경우 우리는 제네릭 타입을 활용하여 문자열 리스트, 정수의 리스트를 각각 별개의 타입으로 표현할 수 있다.

### 제네릭 타입

리스트 타입이 타입 하나를 타입 인자로 받아 어떤 타입의 리스트 타입을 나타내는지 결정할 수 있다.
즉, 이제부터 List 는 어떤 값을 직접적으로 나타내는 타입이 아니다. 대신 타입 인자를 받아 새로운 타입을 만드는 제네릭 타입이다.

`List<Int>` 나 `List<String>` 은 각각 정수 리스트 타입, 문자열 리스트 타입을 표현한다.

이제 리스트가 제네릭 타입이 되었기 때문에 앞선 sum 함수를 문제없이 작성할 수 있다.

```
Int sum(List<Int> list) { ... };
```

이제 sum 함수는 정수의 리스트를 인자로 받는다는 사실을 타입 검사기에 정확히 알려 준다.
따라서 타입 검사기는 각각의 원소가 정수 타입임을 보장할 수 있게 되고, sum 함수의 타입 검사를 성공적으로 통과시킨다.

### 제네릭 클래스

개발자가 자신만의 제네릭 타입을 직접 정의하고 싶은 경우, 새로운 제네릭 타입을 정의할 수도 있다. 이러한 기능을 제네릭 클래스(generic class)라고 한다.

제네릭 클래스는 타입 매개변수를 가진 클래스인데, 정의할 때는 제네릭 함수와 비슷하게 타입 매개변수를 명시해야 하고, 사용할 때는 제네릭 타입으로서 리스트나 맵과 비슷한 방식으로 사용된다.

```
class Chooser<T> {
	T v1;
	T v2;
	T choose() {
		print(this.v1); print(this.v2); print(...);
		Int input = readInt();
		return (input == 0) ? this.v1 : this.v2;
	}
}
```

위 코드는 choose 함수를 제네릭 클래스로 정의한 것이다.

위 코드로 choose 함수를 사용하면 `choose<Int>(1, 2)` 과 같이 사용자에게 어떤 질문을 할 때 매번 타입을 작성해야 하는 번거로움없이 함수를 호출할 수 있다.

```
Chooser<Int> c = Chooser<Int>(1, 2);
Int v = c.choose();
```

