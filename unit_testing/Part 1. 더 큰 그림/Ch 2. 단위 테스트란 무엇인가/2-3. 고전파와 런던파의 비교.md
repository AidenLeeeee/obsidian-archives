고전파와 런던파 간 주요 차이는 단위 테스트의 정의에서 격리 문제를 어떻게 다루는지에 있다.
이는 결국 테스트해야 할 단위의 처리와 의존성 취급에 대한 방법으로 넘어간다.

**고전파 접근법**은 고품질의 테스트를 만들고 단위 테스트의 궁극적인 목표인 프로젝트의 지속 가능한 성장을 달성하는 데 더 적합하다.
그 이유는 취약성에 있다. 목을 사용하는 테스트는 고전적인 테스트보다 불안정한 경향이 있기 때문이다.

**런던파의 접근법**은 입자성이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인하기 때문이다.
또한 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다. 모든 협력자는 테스트 대역으로 대체되기 때문이다.
마지막으로 테스트가 실패하면 어떤 기능이 실패했는지 정확히 알 수 있다. 협력자가 없으면 테스트 대상 클래스 외에 다른 것을 의심할 여지가 없기 때문이다.

### 한 번에 한 클래스만 테스트하기

런던파는 클래스를 단위로 간주한다. 객체지향에서 클래스는 모든 코드베이스의 기초에 위치한 원자 빌딩 블록으로 간주되기 때문에 이로 인해 자연스럽게 클래스를 테스트에서 검증할 원자 단위로 취급하게 되는 것이다. 하지만 이는 오해의 소지가 있다.
사실 테스트는 코드의 단위를 검증해서는 안된다. 오히려 **동작의 단위** 즉, 문제 영역에 의미가 있는 것, 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다. 이는 클래스 단위가 아니며, 어쩌면 여러 클래스에 걸쳐 있거나 심지어 아주 작은 메서드가 될 수도 있다.
정리하면, **테스트가 단일 동작 단위를 검증하는 한 좋은 테스트**이다. 테스트는 해결하는 데 도움이 되는 문제에 대한 이야기를 들려주어야 하며, 프로그래머가 아닌 일반 사람들에게 응집도가 높고 의미가 있어야 한다.

### 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

의존성 그래프가 복잡할 때 협력자를 대신해 목을 사용하면, 쉽게 테스트할 수 있다.
클래스의 직접적인 의존성을 대체해 그래프를 나누게 되어 단위 테스트에서 준비해야 할 작업량을 크게 줄일 수 있기 때문이다.

하지만 이는 잘못된 문제에 초점을 맞추고 있다.
상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다.
대개 클래스 그래프가 커진 것은 코드 설계 문제의 결과다.

목을 사용하는 것은 이 문제를 감추기만 할 뿐, 원인을 해결하지 못한다.

### 버그 위치 정확히 찾아내기

런던 스타일 테스트가 있는 시스템에 버그가 생기면, 보통 SUT 에 버그가 포함된 테스트만 실패한다. 하지만 고전적인 스타일의 테스트에서는 오작동하는 클래스를 참조하는 클라이언트를 대상으로 하는 테스트도 실패할 수 있다. 즉, 하나의 버그가 전체 시스템에 걸쳐 테스트 실패를 야기하는 파급 효과를 초래하는 것이다. 결국 문제의 원인을 찾기가 더 어려워진다.

하지만 이는 큰 문제는 아니다. 테스트를 정기적으로 실행하면 버그의 원인을 쉽게 알아낼 수 있다.
즉, 마지막으로 한 수정이 무엇인지 알기 때문에 문제를 찾는 것은 그리 어렵지 않다. 또한 실패한 테스트를 모두 볼 필요는 없다.
하나를 고치면 다른 것들도 자동으로 고쳐진다.

또한 테스트 스위트 전체에 걸쳐 계단식으로 실패하는 것도 가치가 있다.
버그가 테스트 하나 뿐 아니라 많은 테스트에서 결함으로 이어진다면, 방금 고장 낸 코드 조각이 큰 가치가 있다는 것을 보여준다.

## 고전파와 런던파 사이의 다른 차이점

고전파와 런던파 사이에 남아있는 두 가지 차이점은 다음과 같다.
- **TDD 를 통한 시스템 설계 방식**
- **과도한 명세 문제**

런던 스타일의 단위 테스트는 하향식 TDD 로 이어지며, 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트부터 시작한다.
목을 사용하여 예상 결과와 기대치를 달성하고자 시스템이 통신해야 하는 협력자를 지정한다. 그런 다음 모든 클래스를 구현할 때까지 클래스 그래프를 다져나간다.
목은 한 번에 한 클래스에 집중할 수 있기 때문에 이 설계 프로세스를 가능하게 한다.

반대로 고전 스타일의 단위 테스트는 실제 객체를 다뤄야 하기 때문에 상향식 TDD 로 이어진다. 도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 그 위에 더 둔다.

그러나 고전파와 런던파 간의 가장 중요한 차이점은 과도한 명세 문제, 즉 테스트가 SUT 의 구현 세부 사항에 결합되는 것이다.
런던 스타일은 고전 스타일보다 테스트가 구현에 더 자주 결합되는 편이다. 이로 인해 런던 스타일과 목을 전반적으로 아무 데나 쓰는 것에 대해 주로 이의가 제기된다.