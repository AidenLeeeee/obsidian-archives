### AAA 패턴 사용

AAA 패턴은 각 테스트를 준비, 실행, 검증이라는 세 부분으로 나누어 작성하는 패턴이다.
이 패턴은 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖는 데 도움이 된다. 이러한 일관성이 이 패턴의 가장 큰 장점 중 하나다.
따라서 일단 이 패턴에 익숙해지면 모든 테스트를 쉽게 읽을 수 있고 이해할 수 있다.
이는 전체 테스트 스위트의 유지 보수 비용이 줄어드는 효과를 야기하며, 구조는 아래와 같다.
- Arrange(준비) 구절에서는 SUT 와 해당 의존성을 원하는 상태로 만든다.
- Act(실행) 구절에서는 SUT 에서 메서드를 호출하고 준비된 의존성을 전달하며 출력 값을 캡쳐한다.
- Assert(검증) 구절에서는 결과를 검증한다. 결과는 반환 값이나 SUT 가 협력자의 최종 상태, SUT 가 협력자에 호출한 메서드 등으로 표시될 수 있다.

> **Given-When-Then 패턴**
> AAA 와 유사한 Given-When-Then 패턴도 있다.
> - Given: 준비 구절
> - When: 실행 구절
> - Then: 검증 구절
> 
> 유일한 차이점은 비기술자들에게 위 구조가 더 읽기 쉽다는 것이다.

### 여러 개의 준비, 실행, 검증 구절 피하기

때로 준비, 실행, 검증 구절이 여러 개 있는 테스트를 만날 수 있다.
**테스트 준비 -> 실행 -> 검증 -> 좀 더 실행 -> 다시 검증**

이러한 테스트는 더 이상 단위 테스트가 아니라 통합 테스트다. 여러 개의 동작 단위를 검증하게 되기 때문이다.
위와 같은 테스트 구조는 피하는 것이 좋다.
실행이 하나면 테스트가 단위 테스트 범주에 있게끔 보장하고, 간단하고, 빠르며, 이해하기 쉽다.
따라서 일련의 실행과 검증이 포함된 테스트를 보면 각 동작을 고유의 테스트로 도출하여야 한다.

통합 테스트에서는 실행 구절을 여러 개 두는 것이 괜찮을 때도 있다. 앞에서 살펴봤듯이, 통합 테스트는 느릴 수 있고, 속도를 높이는 방법은 여러 개의 통합 테스트를 여러 실행과 검증이 있는 단일한 테스트로 묶는 것이기 때문이다.
특히, 실행이 동시에 후속 실행을 위한 준비로 제공될 때 유용하다.

그러나 이는 이미 느리지만 더 느려지게 하고 싶지 않은 통합 테스트에서만 적용이 된다. 단위 테스트나 충분히 빠른 통합 테스트에서는 이러한 최적화가 필요하지 않다.

### 테스트 내 if 문 피하기

단위 테스트든 통합 테스트든 테스트는 분기가 없는 간단한 일련의 단계여야 한다.
if 문은 테스트가 한 번에 너무 많은 것을 검증한다는 표시다. 따라서 이러한 테스트는 반드시 여러 개의 테스트로 나눠야 한다.
또한 if 문은 테스트를 읽고 이해하는 것을 더 어렵게 만들기 때문에 통합 테스트에서도 사용을 피해야 한다.

### 각 구절은 얼마나 커야 하는가?

#### 1. 준비 구절이 가장 큰 경우

일반적으로 준비 구절이 세 구절 중 가장 크다.
만약 준비 구절이 너무 커졌다면, 클래스 내 비공개 메서드 또는 별도의 팩토리 클래스로 도출할 수 있다.
오프젝트 마더(Object Mother) 와 테스트 데이터 빌더(Test Data Builder) 패턴을 활용할 수도 있다.

#### 2. 실행 구절이 한 줄 이상인 경우를 경계하라

실행 구절은 보통 코드 한 줄이다. 만약 실행 구절이 두 줄 이상인 경우 SUT 의 공개 API 에 문제가 있을 수 있다.
단일 작업을 수행하는 데 두 개의 메서드 호출이 필요하다면 테스트 자체는 문제가 되지 않지만, 특정 클래스의 API 에 문제가 있다는 의미이다.

단일한 작업은 단일한 메서드로 구현되어야 한다. 만약 두 개의 메서드로 구현되었다면, 두 번째 메서드를 호출하지 않을 때 해당 단일 동작에는 모순이 생기게 된다.
예를 들어, 구매 프로세스라는 단일한 동작에서 고객의 상품 구매와 상품의 재고 감소가 각각의 메서드로 구현되었다면 이는 코드에서 나는 냄새(Smell)이다. 만약 구매 프로세스 내에서 상품의 재고 감소 메서드를 호출하지 않았다면, 고객은 상품을 구매했지만 재고는 감소되지 않을 것이기 때문이다.

이러한 모순을 불변 위반(Invariant Violation)이라고 하며, 잠재적 모순으로부터 코드를 보호하는 행위를 캡슐화(Encapsulation)이라고 한다.

해결책은 코드 캡슐화를 항상 지키는 것이다. 불변을 지키는 한, 불변 위반을 초래할 수 있는 잠재적인 행동을 제거해야 한다.

#### 3. 검증 구절에는 검증문이 얼마나 있어야 하는가

가능한 한 가장 작은 코드를 목표로 하는 전제에 기반을 둔다면 테스트 당 하나의 검증을 갖도록 작성해야 하겠지만, 이는 올바르지 않다.
단위 테스트의 단위는 동작의 단위이지 코드의 단위가 아니다. 따라서 단일 동작 단위는 여러 결과를 낼 수 있으며, 하나의 테스트로 그 모든 결과를 평가하는 것이 좋다.

그렇다고 해도 검증 구절이 너무 커지는 것은 경계해야 한다. 제품 코드에서 추상화가 누락됐을 수 있다.
예를 들어 SUT 에서 반환된 객체 내에서 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 멤버(Equality member)를 정의하는 것이 좋다.
그러면 단일 검증문으로 객체를 기대값과 비교할 수 있다.

#### 4. 종료 단계

준비, 실행, 검증 이후의 단계로 종료 구절을 구분하기도 한다.
테스트에 의해 작성된 파일을 지우거나 데이터베이스 연결을 종료하고자 이 구절을 사용할 수 있다.

종료는 보통 별도의 메서드로 도출하고, 클래스 내 모든 테스트에서 재사용해 AAA 패턴에 포함시키지 않는 것이 좋다.
또한 대부분의 단위 테스트는 종료 구절이 필요 없다. 프로세스 외부에 종속적이지 않으므로 처리해야 할 사이드 이펙트를 남기지 않아야 하기 때문이다.

#### 5. SUT 구분하기

SUT 는 애플리케이션에서 호출하고자 하는 동작에 대한 진입점을 제공한다.
동작은 여러 클래스에 걸쳐 있을 만큼 클 수도 있고 단일 메서드로 작을 수도 있다. 그러나 진입점은 오직 하나만 존재할 수 있다.

따라서 SUT 를 의존성과 구분하는 것이 중요하다. 특히 SUT 가 많은 경우, 테스트 대상을 찾는 데 시간을 너무 많이 들일 필요가 없다. 그렇게 하기 위해 테스트 내 SUT 이름을 sut 로 작명할 수 있다.

#### 6. 준비, 실행, 검증 주석 제거하기

의존성에서 SUT 를 떼어내는 것이 중요한 것처럼, 테스트 내에서 각 준비, 실행, 검증 단계를 구분하는 것 역시 중요하다.
이를 위한 한 가지 방법은 각 구절을 시작하기 전에 주석을 작성하는 것이고, 다른 방법은 빈 줄로 분리하는 것이다.

빈 줄로 구절을 구분하면 대부분의 단위 테스트에서 효과적이며, 간결성과 가독성 사이에서 균형을 잡을 수 있다.
그러나 이는 대규모 테스트에서는 잘 작동하지 않는다. 대규모 테스트에서는 준비 단계에 빈 줄을 추가해 설정 단계를 구분할 수도 있기 때문이다.

- AAA 패턴을 따르고 준비 및 검증 구절에 빈 줄을 추가하지 않아도 되는 테스트라면 구절 주석들을 제거하라.
- 그렇지 않으면 구절 주석을 유지하라.