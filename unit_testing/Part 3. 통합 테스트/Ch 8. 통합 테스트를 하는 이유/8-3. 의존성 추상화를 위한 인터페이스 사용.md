단위 테스트에서 가장 많이 오해하는 주제 중 하나는 인터페이스 사용이다.
인터페이스를 둔 이유를 개발자들이 자주 잘못 설명하고, 그 결과 남용하는 경향이 있다.

### 인터페이스와 느슨한 결합

많은 개발자가 데이터베이스나 메시지 버스와 같은 프로세스 외부 의존성을 위해 인터페이스를 도입한다. 심지어 인터페이스에 구현이 하나만 있는 경우에도 그렇다.
이렇게 인터페이스를 사용하는 이유는 아래와 같다.
- 프로세스 외부 의존성을 추상화해 느슨한 결합을 달성하고,
- 기존 코드를 변경하지 않고 새로운 기능을 추가해 공개 폐쇄 원칙을 지키기 때문이다.

하지만 위의 두 가지 이유는 모두 오해다.
단일 구현을 위한 인터페이스는 추상화가 아니며, 해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않다.
진정한 추상화는 발견하는 것이지, 발명하는 것이 아니다. 의미상 추상화가 이미 존재하지만 코드에서 아직 명확하게 정의되지 않았을 때 그 이후에 발견되는 것이다. 따라서 인터페이스가 진정으로 추상화되려면 구현이 적어도 두 가지는 있어야 한다.

그 다음 이유는 더 기본적인 원칙인 YAGNI(You aren't gonna need it)을 위반하기 때문이다.
YAGNI 는 현재 필요하지 않은 기능에 시간을 들이지 말라는 것이다. 이러한 향후 기능이 어떤지 설명하려고 기능을 개발해서도, 기존 코드를 수정해서도 안 된다. 여기에는 크게 두 가지 이유가 있다.
- 기회 비용: 현재 비즈니스 담당자들에게 필요하지 않은 기능에 시간을 보낸다면, 지금 당장 필요한 기능을 제치고 시간을 허비하는 것이다. 또한 마침내 비즈니스 담당자가 해당 기능을 요구했을 때, 눈높이는 높아졌기 때문에 여전히 작성한 코드를 수정해야 한다. 따라서 처음부터 실제 필요에 따라 기능을 구현하는 것이 더 유리하다.
- 프로젝트 코드가 적을수록 좋다. 만일을 위해 코드를 작성하면 코드베이스의 소유 비용이 불필요하게 증가한다.

### 프로세스 외부 의존성에 인터페이스를 사용하는 이유?

그렇다면 각 인터페이스에 구현이 하나만 있다고 가정할 때 프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇일까?
이는 **목을 사용하기 위함**이다. 인터페이스가 없으면 테스트 대역을 만들 수 없으므로 테스트 대상 시스템과 프로세스 외부 의존성 간의 상호 작용을 확인할 수 없다.

따라서 이러한 의존성을 목으로 처리할 필요가 없다면, 프로세스 외부 의존성에 대한 인터페이스를 작성하지 말라.
정리하면 비관리 의존성만 목으로 처리하므로, 결국 비관리 의존성에 대해서만 인터페이스를 작성하라는 지침과 같다.

### 프로세스 내부 의존성을 위한 인터페이스 사용

때로는 프로세스 외부 의존성뿐만 아니라 프로세스 내부 의존성도 인터페이스 기반인 코드를 볼 수 있다.
하지만 이 또한 마찬가지다. 해당 인터페이스에 대한 구현이 하나만 있다고 가정하면, 이는 좋지 않은 신호다.
도메인 클래스에 대해 단일 구현으로 인터페이스를 도입하는 이유는 목으로 처리하기 위한 것 뿐인데, 프로세스 외부 의존성과 달리 도메인 클래스 간의 상호 작용을 확인해서는 안 된다.
그렇게 하면 깨지기 쉬운 테스트(구현 세부 사항과 결합된 테스트)로 이어지고, 결국 리팩터링 내성이 떨어지게 된다.