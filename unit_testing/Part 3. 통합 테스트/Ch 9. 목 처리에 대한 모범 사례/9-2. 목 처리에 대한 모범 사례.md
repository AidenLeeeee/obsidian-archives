
### 목은 통합 테스트만을 위한 것

목은 통합 테스트만을 위한 것이며 단위 테스트에서 목을 사용해서는 안된다.
비즈니스 로직과 오케스트레이션은 코드베이스에서 분리되어야 하는데, 이는 각각 도메인 모델과 컨트롤러라는 고유 계층 두 개로 만들어지게 된다. 코드가 복잡하거나 프로세스 외부 의존성과 통신할 수 있지만, 둘 다는 아니기 때문이다. 결국 도메인 모델에 대한 테스트는 단위 테스트 범주에 속하며, 컨트롤러를 다루는 테스트는 통합 테스트다. 목은 비관리 의존성에만 해당하며 컨트롤러만 이러한 의존성을 처리하는 코드이기 때문에 통합 테스트에서 컨트롤러를 테스트할 때만 목을 사용해야 한다.

### 테스트당 목이 하나일 필요는 없음

하나의 테스트에서 목이 둘 이상인 경우, 한 번에 여러 가지를 테스트할 가능성이 있기 때문에 테스트당 목을 하나만 두라는 지침이 있을 수 있다.
하지만 단위 테스트의 '단위'는 코드 단위가 아니라 동작 단위를 의미한다. 즉 동작 단위를 구현하는 데 필요한 코드의 양은 관계가 없다. 단일 클래스부터 여러 클래스에 이르기까지 다양하게 걸쳐 있을 수 있고, 아주 작은 메서드에 불과할 수도 있다.

이는 목을 사용하더라도 동일하다. 동작 단위의 검증에 필요한 목의 개수는 고려할 필요가 없다.

### 호출 횟수 검증하기

비관리 의존성과의 통신에 관해서는 다음 두 가지를 모두 확인해야 한다.
- 예상하는 호출이 있는가?
- 예상치 못한 호출은 없는가?

이는 비관리 의존성과의 하위 호환성을 지켜야 하는 데서 비롯된다. 호환성은 양방향이어야 한다.
즉, 애플리케이션은 외부 시스템이 예상하는 메시지를 생략해서는 안 되며 예상치 못한 메시지도 생성해서는 안 된다. 테스트 대상 시스템이 다음과 같이 메시지를 전송하는지 확인하는 것만으로는 충분하지 않다.

### 보유 타입만 목으로 처리하기

서드파티 라이브러리 위에 항상 어댑터를 작성하고 기본 타입 대신 해당 어댑터를 목으로 처리해야 한다. 이유는 아래와 같다.
- 서드파티 코드의 작동 방식에 대해 깊이 이해하지 못하는 경우가 많다.
- 해당 코드가 이미 내장 인터페이스를 제공하더라도 목으로 처리한 동작이 실제로 외부 라이브러리와 일치하는지 확인해야 하므로, 해당 인터페이스를 목으로 처리하는 것은 위험하다.
- 서드파티 코드의 기술 세부 사항까지는 꼭 필요하지 않기에 어댑터는 이를 추상화하고, 애플리케이션 관점에서 라이브러리와의 관계를 정의한다.

실제로 어댑터는 코드와 외부 환경 사이의 손상 방지 게층으로 작동한다.
- 어댑터를 통해 기본 라이브러리의 복잡성을 추상화할 수 있다.
- 어댑터를 통해 라이브러리에서 필요한 기능만 노출할 수 있다.
- 어댑터를 통해 프로젝트 도메인 언어를 사용해 동작을 수행할 수 있다.