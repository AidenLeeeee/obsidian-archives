
데이터베이스 트랜잭션 관리는 제품 코드와 테스트 코드 모두에 중요한 주제다.
제품 코드에서 트랜잭션 관리를 적절히 하면 데이터 모순을 피할 수 있다. 테스트에서는 운영 환경에 근접한 설정으로 데이터베이스 통합을 검증하는 데 도움이 된다.

### 제품 코드에서 데이터베이스 트랜잭션 관리하기

읽기 전용 연산 중에는 여러 트랜잭션을 열어두어도 괜찮지만, 비즈니스 연산에 데이터 변경이 포함된다면, 모순을 피하고자 연산에 포함된 모든 업데이트는 원자적이어야 한다.

**데이터베이스 트랜잭션에서 데이터베이스 연결 분리하기**
잠재적인 모순을 피하려면 결정 유형을 두 가지로 나누어야 한다
- 업데이트할 데이터
- 업데이트 유지 또는 롤백 여부

컨트롤러는 이러한 결정을 동시에 내릴 수 없으므로 이렇게 분리하는 것이 중요하며, 비즈니스 연산의 모든 단계가 성공했을 때 업데이트를 수행할 수 있는지 여부만 안다. 또한 데이터베이스에 접근하고 업데이트를 시도해야만 이러한 단계를 밟을 수 있다.
Database 클래스를 레포지토리(Repository)와 트랜잭션으로 나누어서 이러한 책임을 구분할 수 있다.
- 레포지토리는 데이터베이스의 데이터에 대한 접근과 수정을 가능하게 하는 클래스다.
- 트랜잭션은 데이터 업데이트를 완전히 커밋하거나 롤백하는 클래스다. 데이터 수정의 원자성 확보를 위해 기본 데이터베이스 트랜잭션에 의존하는 사용자 정의 클래스다.

레포지토리와 트랜잭션은 책임이 서로 다르며 수명도 다르다. 트랜잭션은 전체 비즈니스 연산 동안 있으며 연산이 끝나면 폐기된다. 반면에 레포지토리는 수명이 짧다. 데이터베이스 호출이 완료되는 즉시 레포지토리를 폐기할 수 있다. 결국 레포지토리는 항상 현재 트랜잭션 위에서 작동한다. 데이터베이스에 연결할 때는 레포지토리가 트랜잭션에 등록해서 연결 중에 이뤄진 모든 수정 사항이 추후 트랜잭션에 의해 롤백될 수 있도록 한다.

**작업 단위로 트랜잭션 업그레이드하기**
레포지토리와 트랜잭션을 도입하면 잠재적인 데이터 모순을 피할 수 있지만 더 좋은 방법이 있다. Transaction 클래스를 작업 단위로 업그레이드할 수 있다.

- 작업 단위에는 비즈니스 연산의 영향을 받는 객체 목록이 있다. 작업이 완료되면, 작업 단위는 데이터베이스를 변경하기 위해 해야 하는 업데이트를 모두 파악하고 이러한 업데이트를 하나의 단위로 실행한다.

일반 트랜잭션과 비교해 작업 단위가 갖는 가장 큰 장점은 업데이트 지연이다. 트랜잭션과 달리 작업 단위는 비즈니스 연산 종료 시점에 모든 업데이트를 실행하므로 데이터베이스 트랜잭션의 기간을 단축하고 데이터 혼잡을 줄인다. 이 패턴은 데이터베이스 호출 수를 줄이는 데도 도움이 된다.

### 통합 테스트에서 데이터베이스 트랜잭션 관리하기

테스트 구절 간에 데이터베이스 트랜잭션이나 작업 단위를 재사용하지 말라.

예를 들어, AAA 패턴을 사용하는 테스트에서 Arrange, Act, Assert 의 모든 구절에 동일한 트랜잭션을 사용할 경우, 컨트롤러가 운영 환경에서 하는 것과 다른 환경을 만들기 때문에 문제가 된다.

동작 모순에 빠지지 않으려면 통합 테스트를 가능한 한 운영 환경에서와 비슷하게 해야 한다.
즉, Act 구절에서 트랜잭션을 다른 구절과 공유하면 안된다. 각각의 구절은 개별적으로 트랜잭션을 호출해 사용해야 한다.